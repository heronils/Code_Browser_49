//[of]Global functions:Global functions
//[of]:Activesection	\:\: Section
function Activesection
	return Section (Activeview section)

//[of]:~ test
//[c]~ function test
//[c]	~ print (Activesection Repr)
//[cf]
//[cf]
//[of]:Activelanguage	\:\: Language
function Activelanguage
	return Activefile language

//[of]:~ test
//[c]~ function test
//[c]	~ print (Activelanguage name)
//[cf]
//[cf]
//[of]:Activeview	\:\: TextView
function Activeview
	return frame activeView
//[cf]
//[of]:Activefile	\:\: TextView
function Activefile
	return frame activeFile
//[cf]
//[of]:Indenttoken	\:\: String
//[c]Todo: Activelanguage expandTabulation always returns true, even if set to false
//[c]in the preferences.cbc. How to solve?

function Indenttoken
	var lang = Activelanguage name

//[c]	These languages enforce two spaces for indenting code
	if lang == "Elm"
		return "  "

	else
//[c]		Outcomment this if you want to use spaces for indentation.
//[c]		Also 'expand-tabulation'	has to be set to 'false' in
//[c]		preferences.cbc -> 'Languages' -> 'Default' -> 'Tabs'.
		return "\t"

//[c]		Outcomment this if you want to use Tabs.
//[c]		'expand-tabulation'	has to be set to 'true'.
//[c]		~ return "    "
	end

//[of]:~ test
//[c]~ function test
//[c]	~ printborder (Indenttoken)
//[cf]
//[cf]
//[of]:Selectedtext	\:\: String
function Selectedtext
	return Activeview selectedText
//[cf]
//[of]:Opencomment	\:\: String
function Opencomment
	var language = Activelanguage
	if language lineComment notEmpty
		return language lineComment
	else
		return language openComment
	end
//[cf]
//[of]:Closecomment	\:\: String
function Closecomment
	var language = Activelanguage
	if language lineComment isEmpty
		return language closeComment
	else
		return ""
	end
//[cf]

//[of]:Strings
//[c]Most functions return StringBuffers and not Strings. This is for performance
//[c]reasons - it prevents making string copies (well, i think it does).
//[c]
//[c]If it is an inplace action i do not return the stringbuffer but nil or sometimes
//[c]a number, indicating eg. how many replacements have been done. For example
//[c]the strip functions do that. This to make users of the library aware of the
//[c]fact that it is happening inplace. This is how Python does it.

//[of]:Buf	\:\: Buffer
//[c]Lazy shortcut

function Buf
	return StringBuffer new
//[cf]

//[of]:tostring	\:\: Thing -> String
//[c]Todo: add 'toString' method to all types defined by this script

function tostring (thing)
	if thing isNil
		return "nil"
	else
		return thing toString
	end

//[of]:~ test
//[c]~ function test
//[c]	~ var o = Output clear

//[c]	~ var buf = Buf
//[c]	~ buf << tostring($a) << $|
//[c]	~ buf << tostring("Hi") << $|
//[c]	~ buf << tostring(1) << $|
//[c]	~ buf << tostring(true) << $|
//[c]	~ buf << tostring(nil)

//[c]	~ o print(buf)
//[cf]

//[cf]
//[of]:tostringbuffer	\:\: Thing -> Buffer
function tostringbuffer (thing)
	return Buf << tostring (thing)

//[of]:~ test
//[c]~ function test
//[c]	~ var o = Output clear

//[c]	~ var ok = " works"
//[c]	~ o print(tostringbuffer($a) << ok)
//[c]	~ o print(tostringbuffer("hi") << ok)
//[c]	~ o print(tostringbuffer(1) << ok)
//[c]	~ o print(tostringbuffer(true) << ok)
//[c]	~ o print(tostringbuffer(nil) << ok)
//[cf]
//[cf]

//[of]:replace	\:\: String|Buffer -> String -> String -> Buffer
function replace (string, oldstring, newstring)
	var buf = Buf
	var stringsize = string size
	var oldsize = oldstring size
	var stophere = stringsize - oldsize
	var relevant = oldstring[0]
	var curpos = 0
	var curchar = nil
	while curpos <= stophere
		curchar = string[curpos]
		if curchar == relevant
			//[of]:maybe replace oldstring with newstring
			var endpos = curpos + oldsize
			var curpos_ = curpos + 1
			var oldpos = 1
			var found = true
			while curpos_ < endpos
				if string[curpos_] <> oldstring[oldpos]
					found = false
					break
				end
				curpos_ = curpos_ + 1
				oldpos = oldpos + 1
			end
			if found
				curpos = curpos_ - 1
				buf << newstring
			else
				buf << curchar
			end
			//[cf]
		else
			buf << curchar
		end
		curpos = curpos + 1
	end
	buf << string range(curpos, stringsize - curpos)

	return buf

//[of]:~ test
//[c]~ function test
//[c]	~ var o = Output clear

//[c]	~ var string = "/* foo */"
//[c]	~ o print(string)

//[c]	~ string = replace (string, "/*", "___oc___")
//[c]	~ o print(string)

//[c]	~ string = replace (string, "*/", "___cc___")
//[c]	~ o print(string)

//[c]	~ string = replace (string, "___oc___", "/*")
//[c]	~ o print(string)

//[c]	~ string = replace (string, "___cc___", "*/")
//[c]	~ o print(string)
//[cf]
//[cf]
//[of]times	\:\: Number -> String -> StringBuffer:times	\:\: Number -> String -> Buffer
function times (num, string)
	var buf = Buf
	var curpos = 0
	while curpos < num
		buf << string
		curpos = curpos + 1
	end
	return buf

//[of]:~ test
//[c]~ function test
//[c]	~ var o = Output clear
//[c]	~ o print(times(3, "hi "))
//[c]	~ o printborder(times(0, "hi "))
//[cf]
//[cf]
//[of]:wrap	\:\: String or Buffer -> Thing -> String or Buffer -> Buffer
function wrap (leftchars, thing, rightchars)
	return Buf << leftchars << tostring (thing) << rightchars

//[of]:~ test
//[c]~ function test
//[c]	~ var o = Output clear
//[c]	~ o print(wrap("(", "hi", ")"))
//[c]	~ o print(wrap("foo ", "bar", " baz"))
//[cf]
//[cf]

//[of]:Stripping
//[of]:lstripstring	\:\: Buffer -> String -> Integer
function lstripstring (buf, string)
	var stringsize = string size
	var howoften = 0
	while buf startsWith (string)
		buf removeRange (0, stringsize)
		howoften = howoften + 1
	end
	return howoften

//[of]:~ test
//[c]~ function test
//[c]	~ var x = Buf << "... ... ... indented"
//[c]	~ lstripstring (x, "... ")
//[c]	~ p(x)
//[cf]
//[cf]
//[of]:rstripstring	\:\: Buffer -> String -> Integer
function rstripstring (buf, string)
	var stringsize = string size
	var howoften = 0
	while buf endsWith (string)
		rcrop (buf, stringsize)
		howoften = howoften + 1
	end
	return howoften

//[of]:~ test
//[c]~ function test
//[c]	~ var x = Buf << "foo bar bar baz baz"
//[c]	~ rstripstring (x, " baz")
//[c]	~ rstripstring (x, " bar")
//[c]	~ p (x)
//[cf]
//[cf]
//[of]:lstripchar	\:\: Buffer -> Buffer -> Integer
function lstripchar (buf, char)
	var bufsize = buf size
	if bufsize == 0
		return 0
	end
	var pos = 0
	while true
		if (pos == bufsize) or (buf[pos] <> char)
			break
		end
		pos = pos + 1
	end
	if pos > 0
		buf removeRange (0, pos)
	end
	return pos

//[of]:~ test
//[c]~ function test
//[c]	~ var x = Buf << "aaabbbccc"
//[c]	~ lstripchar (x, $a)
//[c]	~ lstripchar (x, $b)
//[c]	~ p (x)
//[cf]
//[cf]
//[of]:rstripchar	\:\: Buffer -> Buffer -> Integer
function rstripchar (buf, char)
	var bufsize = buf size
	if bufsize == 0
		return 0
	end
	var pos = bufsize
	while true
		pos = pos - 1
		if (pos < 0) or (buf[pos] <> char)
			pos = pos + 1
			break
		end
	end
	var stripamount = bufsize - pos
	if stripamount > 0
		buf removeRange (pos, stripamount)
	end
	return stripamount

//[of]:~ test
//[c]~ function test
//[c]	~ var x = Buf << "aaabbbccc"
//[c]	~ rstripchar (x, $c)
//[c]	~ rstripchar (x, $b)
//[c]	~ p (x)
//[cf]
//[cf]
//[of]:lstripchars	\:\: String -> Buffer -> Integer
function lstripchars (buf, chars)
	var bufsize = buf size
	var howoften = 0
	while true
		chars each do char
			howoften = howoften + lstripchar (buf, char)
		end
		if buf size == bufsize
			return howoften
		end
		bufsize = buf size
	end

//[of]:~ test
//[c]~ function test
//[c]	~ var x = Buf << "aabbabaaaabaabbbbaac"
//[c]	~ lstripchars (x, "ab")
//[c]	~ p (x)
//[cf]
//[cf]
//[of]:rstripchars	\:\: String -> Buffer -> Integer
function rstripchars (buf, chars)
	var bufsize = buf size
	var howoften = 0
	while true
		chars each do char
			howoften = howoften + rstripchar (buf, char)
		end
		if buf size == bufsize
			return howoften
		end
		bufsize = buf size
	end

//[of]:~ test
//[c]~ function test
//[c]	~ var x = Buf << "abbccbbbcbbccccbcbcbc"
//[c]	~ rstripchars (x, "bc")
//[c]	~ p (x)
//[cf]
//[cf]
//[of]:lstrip	\:\: Buffer -> Integer
function lstrip (buf)
	return lstripchars (buf, "\a\b\f\n\r\t\v\w ")

//[of]:~ test
//[c]~ function test
//[c]	~ var x = Buf << "\t  \t  indented"
//[c]	~ lstrip (x)
//[c]	~ Output clear printborder (x)
//[cf]
//[cf]
//[of]:rstrip	\:\: Buffer -> Integer
function rstrip (buf)
	return rstripchars (buf, "\a\b\f\n\r\t\v\w ")

//[of]:~ test
//[c]~ function test
//[c]	~ var x = Buf << "foo bar  \t\t"
//[c]	~ rstrip (x)
//[c]	~ Output clear printborder (x)
//[cf]
//[cf]
//[of]:strip	\:\: Buffer -> Integer
function strip (buf)
	return lstrip (buf) + rstrip (buf)

//[of]:~ test
//[c]~ function test
//[c]	~ var x = Buf << "\t  \t     \t foo bar  \t\t"
//[c]	~ strip (x)
//[c]	~ Output clear printborder (x)
//[cf]
//[cf]
//[cf]
//[of]:Cropping
//[c]Used by the strip functions

//[c]( crop amount chars
//[of]:lcrop	\:\: Buffer -> Integer -> nil
function lcrop (buf, amount)
	buf removeRange (0, amount)

//[of]:~ test
//[c]~ function test
//[c]	~ var x = Buf << "0123456789"
//[c]	~ lcrop (x, 3)
//[c]	~ p (x)
//[cf]
//[cf]
//[of]:rcrop	\:\: Buffer -> Integer -> nil
function rcrop (buf, amount)
	buf removeRange (buf size - amount, amount)

//[of]:~ test
//[c]~ function test
//[c]	~ var x = Buf << "0123456789"
//[c]	~ rcrop (x, 3)
//[c]	~ p (x)
//[cf]
//[cf]
//[c])

//[c]( crop at position
//[of]:lcropat	\:\: Buffer -> Integer -> nil
//[c]This actually behaves like lcrop. Keeping it for consistency with rcropat

function lcropat (buf, pos)
	buf removeRange (0, pos)

//[of]:~ test
//[c]~ function test
//[c]	~ var x = Buf << "0123456789"
//[c]	~ lcropat (x, 3)
//[c]	~ p (x)
//[cf]
//[cf]
//[of]:rcropat	\:\: Buffer -> Integer -> nil
function rcropat (buf, pos)
	buf removeRange (pos, buf size - pos)

//[of]:~ test
//[c]~ function test
//[c]	~ var x = Buf << "0123456789"
//[c]	~ rcropat (x, 7)
//[c]	same as rcrop (x, 3)
//[c]	~ p (x)
//[cf]
//[cf]
//[c])
//[cf]
//[of]:Indenting lines
//[of]:indentnorm	\:\: Buffer -> Integer -> nil
function indentnorm (buf, indentsize)
	rstrip (buf)
	if not buf isEmpty
		var indented = Buf << times (indentsize, Indenttoken) << buf
		buf removeAll
		buf << indented
	end

//[of]:~ test
//[c]~ function test
//[c]	~ var x = Buf << "hello world   \t"
//[c]	~ indentnorm (x, 3)
//[c]	~ Output clear printborder (x)
//[cf]
//[cf]
//[of]:dedentnorm	\:\: Buffer -> Integer -> nil
//[c]Todo: this also crops non empty chars from the left side of the stringbuffer
//[c]if it has less indent than indentsize suggests.

function dedentnorm (buf, indentsize)
	rstrip (buf)
	if not buf isEmpty
		var amount = indentsize * Indenttoken size
		lcrop (buf, amount)
	end

//[of]:~ test
//[c]~ function test
//[c]	~ var x = Buf << "\t\t\thello world   \t"
//[c]	~ dedentnorm (x, 3)
//[c]	~ Output clear printborder (x)
//[cf]
//[cf]
//[cf]
//[cf]
//[of]:Textblocks
//[of]:totexblock	\:\: Thing -> TextBlock
function totextblock (thing)
	return TextBlock fromString (tostring (thing))
//[cf]
//[of]:indentblock	\:\: TextBlock -> Integer -> nil
function indentblock (block, indentsize)
	block each do y
		var string = Buf << block rowText (y)
		indentnorm (string, indentsize)
		block setRowText (y, string toString)
	end
	var lasttext = Buf << block lastText
	indentnorm (lasttext, indentsize)
	block setLastText (lasttext toString)

//[of]:~ test
//[c]~ function test
//[c]	~ var sec = Activesection
//[c]	~ var block = sec copy
//[c]	~ indentblock (block, 1)
//[c]	~ sec paste (block)
//[cf]
//[cf]
//[of]:dedentblock	\:\: TextBlock -> Integer -> nil
function dedentblock (block, indentsize)
	block each do y
		var string = Buf << block rowText (y)
		dedentnorm (string, indentsize)
		block setRowText (y, string toString)
	end
	var lasttext = Buf << block lastText
	dedentnorm (lasttext, indentsize)
	block setLastText (lasttext toString)

//[of]:~ test
//[c]~ function test
//[c]	~ var sec = Activesection
//[c]	~ var block = sec copy
//[c]	~ dedentblock (block, 1)
//[c]	~ sec paste (block)
//[cf]
//[cf]
//[of]:normend	\:\: TextBlock -> nil
//[c]Adds a newline if the last line contains non whitespace chars

function normend (block)
	var lasttext = Buf << block lastText
	rstrip (lasttext)
	if lasttext notEmpty
		block addText (lasttext toString)
	end
	block setLastText ("")

//[of]:~ test
//[c]~ function test
//[c]	~ var sec = Activesection
//[c]	~ var block = sec copy
//[c]	~ normend (block)
//[c]	~ sec paste (block)
//[cf]
//[cf]
//[cf]
//[of]:Printing
//[c]Lazy development shortcuts for printing stuff to the output buffer.
//[c]This is slow, because eg. for every 'print' call a Section and a Output class
//[c]will be created. Further, the section will always be normalized - a newline may
//[c]be appended. The fast way is to do it like this:
//[c]
//[c]	var o = Output
//[c]	o clear
//[c]	o print("foo")
//[c]	o print("foo") clear print("bar") clear printborder("baz")
//[c]	...
//[c]
//[c]... which only creates the Section and Output wrapper classes once.

//[of]:clear	\:\: nil
function clear
	Output clear
//[cf]
//[of]:print	\:\: nil
function print (thing)
	Output print (thing)
//[cf]
//[of]:clearprint	\:\: nil
function clearprint (thing)
	Output clear print (thing)
//[cf]
//[of]:printborder	\:\: nil
function printborder (thing)
	Output printborder (thing)

//[cf]
//[cf]

//[of]:startundo	\:\: nil
function startundo
	Activeview section startGroup
//[cf]
//[of]:stopundo	\:\: nil
function stopundo
	Activeview section stopGroup
//[cf]

//[of]:smallest	\:\: Number -> Number -> Number
function smallest (num, othernum)
	if num < othernum
		return num
	end
	return othernum

//[of]:~ test
//[c]~ function test
//[c]	~ var o = Output clear
//[c]	~ o print (smallest(0, 10))
//[c]	~ o print (smallest (11, 10))
//[c]	~ o print (smallest (10, 10))
//[cf]
//[cf]
//[of]:biggest	\:\: Number -> Number -> Number
function biggest (num, othernum)
	if num > othernum
		return num
	end
	return othernum

//[of]:~ test
//[c]~ function test
//[c]	~ var o = Output clear
//[c]	~ o print (biggest(0, 10))
//[c]	~ o print (biggest (11, 10))
//[c]	~ o print (biggest (10, 10))
//[cf]
//[cf]

//[of]:somethingselected	\:\: Boolean
function somethingselected
	return not Activeview isSelectionEmpty
//[cf]
//[cf]
//[of]Types:Types
//[c]( Wrappers for predefined Code Browser types
//[of]Section:Section
//[c]Wraps a TextSection. This also serves as a God Object for global variables,
//[c]as it is instantiated in every script anyway.

function Section (textsection)
	return TextSectionWrapper basicNew init (textsection)

class TextSectionWrapper
	attr Textsection

	//[of]init	\:\: TextSection -> Section:init	\:\: TextSection -> Section
	method init (textsection)
		self Textsection = textsection
		return self normend
	//[cf]

	//[of]:Title	\:\: Buffer
	attr _Title

	method Title
		var t = self _Title
		if t isNil
			var textsec = self Textsection
			var par = textsec parent
			t = Buf
			if par isNil
				t << "<root section>"
			else
				t << (par row (textsec line) text)
				strip (t)
			end
			self _Title = t
		end
		return t
	//[cf]
	//[of]:Uid	\:\: Buffer
	//[c]Todo: Make Uid be a date loaded from an external prog,
	//[c]so that i can implement a `fix links` function`.

	attr _Uid

	method Uid
		var u = self _Uid
		if u isNil
			u = Buf << (self Textsection id)
			strip (u)
			self _Uid = u
		end
		return u
	//[cf]
	//[of]:Repr	\:\: Buffer
	attr _Repr

	method Repr
		var r = self _Repr
		if r isNil
			r = Buf
			r << "Section ( "
				r << "title=\"" << self Title << "\" "
				r << "id=\"" << self Uid << "\""
			r << " )"
			self _Repr = r
		end
		return r
	//[cf]
	//[of]:Range	\:\: Range
	attr _Range

	method Range
		var r = self _Range
		if r isNil
			r = Rowrange (self, 0, self Endy)
			self _Range = r
		end
		return r

	//[cf]
	//[of]:Selection	\:\: Range
	method Selection
		var view = Activeview
		var startloc = Location (self, view markLine, view markColumn)
		var endloc = Location (self, view cursorLine, view cursorColumn)
		return Range (startloc, endloc)
	//[cf]
	//[of]:Cursorline	\:\: Line
	method Cursorline
		return Line (self, Activeview cursorLine)
	//[cf]
	//[of]:Lastline	\:\: Line
	method Lastline
		return self lineat (self Endy)
	//[cf]
	//[of]:Cursorlocation	\:\: Location
	method Cursorlocation
		var view = Activeview
		return Location (self, view cursorLine, view cursorColumn)
	//[cf]
	//[of]:Startlocation	\:\: Location
	method Startlocation
		return Location (self, 0, 0)
	//[cf]
	//[of]:Endlocation	\:\: Location
	attr _Endlocation

	method Endlocation
		var loc = self _Endlocation
		if loc isNil
			var y = self Endy
			loc = Location (self, y, self Textsection row (y) size)
			self _Endlocation = loc
		end
		return loc
	//[cf]
	//[of]:Selectionstart	\:\: Location
	method Selectionstart
		var view = Activeview
		return Location (self, view markLine, view markColumn)
	//[cf]
	//[of]:Endy	\:\: Integer
	attr _Endy

	method Endy
		var y = self _Endy
		if y isNil
			y = self Textsection rowsSize - 1
			self _Endy = y
		end
		return y
	//[cf]
	//[of]:Opencomment	\:\: String
	attr _Opencomment

	method Opencomment
		var p = self _Opencomment
		if p isNil
			var language = Activelanguage
			if language lineComment notEmpty
				p = language lineComment
			else
				p = language openComment
			end
			self _Opencomment = p
		end
		return p
	//[cf]
	//[of]:Closecomment	\:\: String
	attr _Closecomment

	method Closecomment
		var s = self _Closecomment
		if s isNil
			var language = Activelanguage
			if language lineComment isEmpty
				s = language closeComment
			else
				s = ""
			end
			self _Closecomment = s
		end
		return s
	//[cf]
	//[of]:Find	\:\: Find
	method Find
		return Find (self)
	//[cf]
	//[of]:Output	\:\: Output
	attr _Output

	method Output
		var o = self _Output
		if o isNil
			o = Output
			self _Output = o
		end
		return o
	//[cf]

	//[of]:normend	\:\: Section
	method normend
		var last= self Lastline
		if not (last istext and last isempty)
			self appendnewline
		end
		return self
	//[cf]
	//[of]:refresh	\:\: Section
	method refresh
		return self refreshdimensions refreshdata
	//[cf]
	//[of]:refreshdata	\:\: Section
	method refreshdata
		self _Uid = nil
		self _Title = nil
		self _Repr = nil
		return self
	//[cf]
	//[of]:refreshdimensions	\:\: Section
	method refreshdimensions
		self _Endy = nil
		self _Endlocation = nil
		return self
	//[cf]
	//[of]:show	\:\: Section
	method show
		frame activeWindow showSection (self Textsection)
		return self
	//[cf]
	//[of]:clear	\:\: Section
	method clear
		self Textsection replaceAll (TextBlock new)
		return self refreshdimensions
	//[cf]
	//[of]:cut	\:\: TextBlock
	method cut
		return self Range cut
	//[cf]
	//[of]:copy	\:\: TextBlock
	method copy
		return self Range copy
	//[cf]
	//[of]:paste	\:\: TextBlock
	method paste (textblock)
		self Range paste (textblock)
		return self
	//[cf]
	//[of]:prepend	\:\: TextBlock -> Section
	method prepend (textblock)
		self Startlocation paste (textblock)
		return self
	//[cf]
	//[of]:prependcomment	\:\: TextBlock -> Section
	method prependcomment (buf)
		var block = TextBlock new
		block addComment (buf toString)
		self prepend (block)
		return self
	//[cf]
	//[of]:append	\:\: TextBlock -> Section
	method append (textblock)
		self Endlocation paste (textblock)
		return self
	//[cf]
	//[of]:appendcomment	\:\: TextBlock -> Section
	method appendcomment (buf)
		var block = TextBlock new
		block addComment (buf toString)
		self append (block)
		return self
	//[cf]
	//[of]:appendnewline	\:\: Section
	method appendnewline
		self Endlocation paste (TextBlock fromString ("\n"))
		return self
	//[cf]
	//[of]:levelat	\:\: Number -> Level
	method levelat (y)
		return Level (self, y)
	//[cf]
	//[of]:paragraphat	\:\: Number -> Paragraph
	method paragraphat (y)
		return Paragraph ( self levelat (y), y )
	//[cf]
	//[of]:lineat	\:\: Number -> Line
	method lineat (y)
		return Line (self, y)
	//[cf]
	//[of]:outcomment	\:\: Section
	method outcomment
		self Range outcomment
		return self

	//[cf]
	//[of]:unoutcomment	\:\: Section
	method unoutcomment
		self Range unoutcomment
		return self

	//[cf]
//[cf]
//[of]:Output
//[c]Wraps the root section of the output buffer = application outputFile root

function Output
	return OutputSectionWrapper basicNew init

class OutputSectionWrapper
	attr File
	attr Section

	//[of]:init	\:\: Output
	method init
		var file = application outputFile
		self File = file
		self Section = Section (file root)
		return self
	//[cf]

	//[of]:show	\:\: Output
	method show
		frame showOutput
		return self
	//[cf]
	//[of]:clear	\:\: Output
	method clear
		self Section clear
		self File synchronize
		return self
	//[cf]
	//[of]:_print	\:\: Buffer -> Output
	method _print (stringbuffer)
		self Section append (totextblock (stringbuffer))
		self show
		self File synchronize
		return self
	//[cf]
	//[of]:prnt	\:\: Thing -> Output
	method prnt (thing)
		return self _print ( tostringbuffer (thing) )
	//[cf]
	//[of]:print	\:\: Thing -> Output
	method print (thing)
		return self _print ( tostringbuffer (thing) << "\n" )
	//[cf]
	//[of]:printborder	\:\: Thing -> Output
	//[c]Useful for printing whitespace

	method printborder (thing)
		self Section append (totextblock (wrap ("|", thing, "|\n")))
		self show
		self File synchronize
		return self
	//[cf]
//[cf]
//[of]:Find
//[c]Wraps FindData

function Find (sec)
	return FindDataWrapper basicNew init (sec)

class FindDataWrapper
	attr Section
	attr Scope
	attr Regex
	attr Direction
	attr Case
	attr Whole
	attr From

	//[of]:init	\:\: Section -> Findresult
	method init (sec)
		self Section = sec
		self Scope = find_in_file
		self Regex = false
		self Direction = find_next
		self Case = true
		self Whole = false
		self From = nil
		return self
	//[cf]

	//[of]:_find	\:\: String -> Findresult
	method _find (searchstring)
		var finddata = FindData new
		finddata setScope (self Scope)
		finddata setRegularExpression (self Regex)
		finddata setDirection (self Direction)
		finddata setCaseSensitive (self Case)
		finddata setMatchWholeWord (self Whole)
		finddata setSearchString (searchstring)
		if self From isNil
			self From = self Section Cursorlocation
		end
		var loc = self From
		var result = nil
		if self Direction == find_next
	//[c]		Todo: jump over the variable at the cursor
		else
			result = finddata find (self Section Textsection, loc Y, loc X, true)
		end
		if result isNil
			return nil
		else
			return Findresult (result)
		end
	//[cf]
	//[of]:prev	\:\: String -> Findresult
	method prev (searchstring)
		self Direction = find_previous
		return self _find (searchstring)
	//[cf]
	//[of]:next	\:\: String -> Findresult
	method next (searchstring)
		self Direction = find_next
		return self _find (searchstring)
	//[cf]
	//[of]:definition	\:\: String -> String -> Findresult
	method definition (langname, identifier)
		if langname == "Code-Browser-Script"
			return self cbsdefinition (identifier)
		elsif langname == "python"
			return self pythondefinition (identifier)
		else
			clearprint (Buf << "The go to definition feature is currently " <<
			"not implemented for " << langname << ".")
		end
	//[cf]
	//[of]:cbsdefinition	\:\: String -> Findresult
	method cbsdefinition (name)
		self Regex = true
		self Whole = true
		var searchtext = Buf
		searchtext << "(class|method|function|attr|var)[ 	]+" << name
		searchtext = searchtext toString
		var result = self prev (searchtext)
		if result notNil
			var loc = result Location
			var sec = result Section
			var txt = result Section lineat (loc Y) Text
			if txt startsWith ("class")
				result Location = Location (sec, loc Y, loc X + 6)
			elsif txt startsWith ("method")
				result Location = Location (sec, loc Y, loc X + 7)
			elsif txt startsWith ("function")
				result Location = Location (sec, loc Y, loc X + 9)
			elsif txt startsWith ("attr")
				result Location = Location (sec, loc Y, loc X + 5)
			elsif txt startsWith ("var")
				result Location = Location (sec, loc Y, loc X + 4)
			end
		end
		return result
	//[cf]
	//[of]:pythondefinition	\:\: String -> Findresult
	method pythondefinition (name)
		self Regex = true
		self Whole = true
		var searchtext = Buf
		searchtext << "((class|def)[ 	]+" << name << ")"
		searchtext << "|(" << name << "[ 	]+" << "[=,])"
		searchtext = searchtext toString
		var result = self prev (searchtext)
		if result notNil
			var loc = result Location
			var txt = result Section lineat (loc Y) Text
			if txt startsWith ("class")
				result Location = Location (self Section, loc Y, loc X + 6)
			elsif txt startsWith ("def")
				result Location = Location (self Section, loc Y, loc X + 4)
			end
		end
		return result
	//[cf]
//[cf]
//[of]:Findresult
function Findresult (findresult)
	return FindresultWrapper basicNew init (findresult)

class FindresultWrapper
	attr Section
	attr Location
	attr Size

	//[of]:init	\:\: FindResult -> Findresult
	method init (findresult)
		self Section = Section (findresult section)
		self Location = Location (self Section, findresult line, findresult column)
		self Size = findresult size
		return self
	//[cf]
//[cf]
//[c])

//[c]( Location related
//[of]Range:Range
//[c]A Range wraps a start and end
//[l]:Location:#Types/Location

function Range (startloc, endloc)
	return RangeClass basicNew init (startloc, endloc)

function Rowrange (sec, y1, y2)
	var startloc = Location(sec, y1, 0)
	var endloc = Location(sec, y2, 0)
	return RangeClass basicNew init (startloc, endloc)

class RangeClass
	attr Section
	attr Start
	attr End

	//[of]:init	\:\: Section -> Location -> Location -> Range
	method init (startloc, endloc)
	//[c]	~ assert (startloc Section == endloc Section)
		self Section = startloc Section
		self Start = startloc
		self End = endloc
		return self
	//[cf]

	//[of]:Repr	\:\: Buffer
	method Repr
		return Buf << "Range(start=" << (self Start Repr) <<
		", end=" << (self End Repr) << ")"
	//[cf]

	//[of]:clone	\:\: Range
	method clone
		return Range (self Start clone, self End clone)
	//[cf]
	//[of]blockify	\:\: Range:blockify	\:\: Range
	//[c]Expand a range to be a bunch of lines. It then always ends with a newline.

	method blockify
		var s = self Start
		var e = self End
		if e > s  // like in a forward selection
			s X = 0
			if e X > 0
				e Y = (e Y + 1)
				e X = 0
			end
		elsif s > e  // like in a backwards selection
			e X = 0
			if s X > 0
				s Y = (s Y + 1)
				s X = 0
			end
		else  // the range is a point --> select the line
			s X = 0
			e X = 0
			e Y = (s Y + 1)
		end
		return self

	//[cf]
	//[of]:normdirection	\:\: Range
	method normdirection
		var s = self Start
		var e = self End
		if (s > e)
			self Start = e
			self End = s
		end
		return self
	//[cf]
	//[of]:up	\:\: Range
	method up
		self Start up
		self End up
		return self
	//[cf]
	//[of]:down	\:\: Range
	method down
		self Start down
		self End down
		return self
	//[cf]
	//[of]:left	\:\: Range
	method left
		self Start left
		self End left
		return self
	//[cf]
	//[of]:right	\:\: Range
	method right
		self Start right
		self End right
		return self
	//[cf]
	//[of]:empty	\:\: Range
	method empty
		return self paste (TextBlock fromString (""))
	//[cf]
	//[of]:select	\:\: Range
	method select
		Activeview select (self Start Y, self Start X, self End Y, self End X)
		return self
	//[cf]
	//[of]:outcomment	\:\: Range
	//[c]The range must end with a newline. See the
//[l]:blockify:#Types/Range/blockify	\:\: Range
	//[c]method.

	method outcomment
		var sec = self Start Section
		var y = self Start Y
		var endy = self End Y
		while y < endy
			Line (sec, y) outcomment
			y = y + 1
		end
		return self
	//[cf]
	//[of]:unoutcomment	\:\: Range
	//[c]The range must end with a newline. See the
//[l]:blockify:#Types/Range/blockify	\:\: Range
	//[c]method.

	method unoutcomment
		var sec = self Start Section
		var y = self Start Y
		var endy = self End Y
		while y < endy
			Line (sec, y) unoutcomment
			y = y + 1
		end
		return self
	//[cf]
	//[of]:cut	\:\: TextBlock
	method cut
		var textblock = self copy
		self empty
		return textblock
	//[cf]
	//[of]:copy	\:\: TextBlock
	method copy
		return self Section Textsection copyBlock (
		self Start Y, self Start X, self End Y, self End X)
	//[cf]
	//[of]:paste	\:\: TextBlock -> Range
	method paste (textblock)
		var y1 = self Start Y
		var x1 = self Start X
		self Section Textsection replaceText (
			y1, x1, self End Y, self End X, textblock)
		var blocksize = textblock size
		if blocksize == 0
			self End Y = y1
			self End X = x1 + textblock lastText size
		else
			self End Y = y1 + blocksize
			self End X = textblock lastText size
		end
		return self
	//[cf]
//[cf]
//[of]Location:Location
//[c]A Location is a point in the file, wrapping x and y position

function Location (sec, y, x)
	return LocationClass basicNew init (sec, y, x)

class LocationClass
	attr Section
	attr Y
	attr X

	//[of]:init	\:\: Section -> Number -> Number -> Location
	method init (sec, y, x)
		self Section = sec
		self Y = y
		self X = x
		return self
	//[cf]

	//[of]:Repr	\:\: Buffer
	method Repr
		return Buf <<
			"Location(line=" <<
			(self Y toString) <<
			" column=" <<
			(self X toString) <<
			")"
	//[cf]
	//[of]:Range	\:\: Range
	method Range
		var loc = Location(self Section, self Y, self X)
		return Range (loc, loc clone)
	//[cf]

	//[of]:==	\:\: Location -> Boolean
	method _eq (loc)
		return (self Y == loc Y) and (self X == loc X)
	//[cf]
	//[of]:<>	\:\: Location -> Boolean
	method _ne (loc)
		return (self Y <> loc Y) or (self X <> loc X)
	//[cf]
	//[of]:>	\:\: Location -> Boolean
	method _gt (loc)
		return (self Y > loc Y) or ( (self Y == loc Y) and (self X > loc X) )
	//[cf]
	//[of]:<	\:\: Location -> Boolean
	method _lt (loc)
		return (self Y < loc Y) or ( (self Y == loc Y) and (self X < loc X) )
	//[cf]

	//[of]:clone	\:\: Location
	method clone
		return Location (self Section, self Y, self X)
	//[cf]
	//[of]:putcursor	\:\: Location
	method putcursor
		self Section show
		var view = Activeview
	//[c]	~ assert (view section == self Section Textsection)
		view moveCursor (self Y, self X, false)
		view adjustPage

		return self
	//[cf]
	//[of]:paste	\:\: TextBlock -> Location
	method paste (textblock)
		var sec = self Section
		sec Textsection replaceText (self Y, self X, self Y, self X, textblock)
		sec refreshdimensions
		return self
	//[cf]
	//[of]:up	\:\: Location
	method up
		self Y = (self Y) - 1
		return self
	//[cf]
	//[of]:down	\:\: Location
	method down
		self Y = (self Y) + 1
		return self
	//[cf]
	//[of]:left	\:\: Location
	method left
		var x = self X
		if x > 0
			self X = x - 1
		end
		return self
	//[cf]
	//[of]:right	\:\: Location
	method right
		self X = self X + 1
		return self
	//[cf]
//[cf]
//[c])

//[c]( Line related
//[of]Level:Level
//[c]A level is all lines which are indented the same or more.
//[c]A level contains one or more
//[l]:paragraphs:#Types/Paragraph

function Level (sec, index)
	return LevelClass basicNew init (sec, index)

class LevelClass
	attr Section
	attr Indent
	attr Start
	attr End

	//[of]:init	\:\: Section -> Integer -> Level
	method init (sec, index)
		self Section = sec
		return self _findborders (index)
	//[cf]

	//[of]_findborders:_findborders	\:\: Integer -> Level
	method _findborders (index)
		var line_ = Line (self Section, index)
		var remember = line_ clone
		var indent = line_ Indent
		self Indent = indent
		while not line_ isfirst and ( (line_ isempty) or not (line_ Indent < indent) )
			line_ prev
		end
		if (line_ Indent < indent) or line_ isempty
			line_ next
			while line_ isempty
				line_ next
			end
		end
		self Start = line_
		line_ = remember
		while not line_ islast and ( (line_ isempty) or not (line_ Indent < indent) )
			line_ next
		end
		if (line_ Indent < indent) or line_ isempty
			line_ prev
			while line_ isempty
				line_ prev
			end
		end
		self End = line_
		return self
	//[cf]

	//[of]:Indentstring	\:\: Buffer
	attr _Indentstring

	method Indentstring
		var indentstring = self _Indentstring
		if indentstring isNil
			indentstring = times (self Indent, Indenttoken)
			self _Indentstring = indentstring
		end
		return indentstring
	//[cf]
	//[of]:Repr	\:\: Buffer
	method Repr
		return Buf << "Level(start=" << (self Start Repr) << " end=" << (self End Repr) << ")"
	//[cf]
//[cf]
//[of]Paragraph:Paragraph
//[c]A Paragraph is all lines which are indented the same or more and which are not
//[c]separated by empty lines. An
//[l]:unfolded:#Actions/action_unfold	\:\: nil
//[l]:Section:#Types/Section
//[c]also counts as paragraph.
//[c]
//[c]A paragraph is always part of a
//[l]:Level:#Types/Level

function Paragraph (level, index)
	return ParagraphClass basicNew init (level, index)

class ParagraphClass
	attr Level
	attr Title
	attr Start
	attr End

	//[of]:init	\:\: Level -> Integer -> Paragraph
	method init (level, index)
		self Level = level
		return self _findborders (index)
	//[cf]
	//[of]_findborders:_findborders	\:\: Integer -> Paragraph
	//[c]Todo: split this up into findstartborder and findendborder

	method _findborders (y)
		var level = self Level
		var sec = level Section
		var line_ = Line (sec, y)
		if line_ isopener
			self Start = line_
			self End = line_ clone matchingcloser (level)
		elsif line_ iscloser
			self End = line_
			self Start = line_ clone matchingopener (level)
		else
			var levelstart = level Start
			var levelend = level End
			var remember = line_ clone
			//[of]startline:startline
			if line_ > levelstart
				var wantindent = line_ Indent
				var curindent = wantindent
				while line_ > levelstart
					line_ prev
					if line_ isempty
						if curindent == wantindent
							line_ next
							break
						end
					elsif line_ iscloser
						if line_ Indent == wantindent
							line_ next
							while line_ isempty
								line_ next
							end
							break
						else
							line_ matchingopener (level)
							curindent = line_ Indent
						end
					elsif line_ isopener
						line_ next
						while line_ isempty
							line_ next
						end
						break
					else
						curindent = line_ Indent
					end
				end
			end
			self Start = line_
			//[cf]
			//[of]endline:endline
			line_ = remember
			if line_ < levelend
				var lastwaswhitespace = false
				var wantindent = line_ Indent
				while line_ < levelend
					line_ next
					if line_ isempty
						lastwaswhitespace = true
					elsif line_ isopener
						if line_ Indent == wantindent
							line_ prev
							while line_ isempty
								line_ prev
							end
							break
						else
							line_ matchingcloser (level)
							lastwaswhitespace = false
						end
					elsif line_ iscloser
						line_ prev
						while line_ isempty
							line_ prev
						end
						break
					else
						if (line_ Indent == wantindent) and lastwaswhitespace
							line_ prev
							while line_ isempty
								line_ prev
							end
							break
						end
						lastwaswhitespace = false
					end
				end
			end
			self End = line_
			//[cf]
		end
		var startline = self Start
		if startline isopener and self End iscloser
			var title = Buf << startline Text
			lcrop (title, 2)
	//[c]		~ lcrop (title, sec Opentoken size)
			self Title = title
		end
		return self
	//[cf]

	//[of]:Repr	\:\: Buffer
	method Repr
		return Buf << "Paragraph(start=" << (self Start Repr) << " end=" << (self End Repr) << ")"
	//[cf]
	//[of]:Range	\:\: Range
	attr _Range

	method Range
		var range_ = self _Range
		if range_ isNil
			range_ = Rowrange (
				self Level Section,
				self Start Index,
				(self End Index) + 1)
			self _Range = range_
		end
		return range_
	//[cf]
	//[of]Fold	\:\: TextBlock:Fold	\:\: TextBlock
	method Fold
		var textblock = TextBlock new
		var indentstring = self Level Indentstring
		var title = self Title

	//[c]	Todo: generate section UIDs from date using python
	//[c]	eg. "2019-12-25 17:23:28.45"
	//[c]	i can then implement a `fixlinktargets` function
		if title isNil
			textblock addSection ((indentstring << "...") toString, "")
		else
			textblock addSection ((indentstring << title) toString, title toString)
		end

		var childblock = self Range copy
		dedentblock (childblock, self Level Indent)
		if title notNil
			childblock remove (childblock size - 1)
			childblock remove (0)
		end
		textblock rowSection (0) replaceAll (childblock)
		return textblock
	//[cf]

	//[of]:fold	\:\: Paragraph
	method fold
		self Range paste (self Fold)
		self End = self Start refresh clone

	//[cf]
	//[of]:paste	\:\: TextBlock -> Paragraph
	method paste (textblock)
		normend(textblock)
		self Range paste (textblock)
		return self _findborders (self _startline Index)
	//[cf]
//[cf]
//[of]Line:Line
//[c]A Line represents one line in the code.

function Line (sec, index)
	return LineClass basicNew init (sec, index)

class LineClass
	attr Section
	attr Index

	//[of]init	\:\: Section -> Number -> Line:init	\:\: Section -> Number -> Line
	method init (sec, index)
		self Index = smallest (index, sec Endy)
		self Section = sec
		return self
	//[cf]

	//[of]:_load	\:\: Line
	method _load
		var buf = Buf << (self Row text)
		rstrip (buf)
		var indent = lstripstring (buf, Indenttoken)
		self _Text = buf
		self _Indent = indent
		return self
	//[cf]

	//[of]:Text	\:\: Buffer
	attr _Text

	method Text
		if self _Text isNil
			self _load
		end
		return self _Text
	//[cf]
	//[of]Indent	\:\: Integer:Indent	\:\: Integer
	attr _Indent

	method Indent
		if self _Indent isNil
			self _load
		end
		return self _Indent
	//[cf]
	//[of]:Indentstring	\:\: Buffer
	attr _Indentstring

	method Indentstring
		var s = self _Indentstring
		if s isNil
			s = times (self Indent, Indenttoken)
			self _Indentstring = s
		end
		return s
	//[cf]
	//[of]:Repr	\:\: Buffer
	method Repr
		return Buf <<
			"Line(" <<
			self Index toString <<
			" \"" <<
			self Text <<
			"\" indent=" <<
			self Indent toString <<
			")"
	//[cf]
	//[of]:Row	\:\: TextRow
	attr _Row

	method Row
		var r = self _Row
		if r isNil
			r = self Section Textsection row (self Index)
			self _Row = r
		end
		return r
	//[cf]
	//[of]:Startlocation	\:\: Location
	method Startlocation
		return Location (self Section, self Index, self Indentstring size)
	//[cf]
	//[of]:Smartlocation	\:\: Location
	method Smartlocation
		var xpos = 0
		if self isopener
			xpos = 2 + self Indentstring size
		else
			xpos = self Indentstring size
		end
		return Location (self Section, self Index, xpos)
	//[cf]
	//[of]:Endlocation	\:\: Location
	method Endlocation
		return Location (self Section, self Index, self Indentstring size + self Text size)
	//[cf]
	//[of]Childsection	\:\: Section:Childsection	\:\: Section
	method Childsection
		return Section (self Row section)
	//[cf]
	//[of]Block:Paragraph	\:\: Paragraph
	method Paragraph
		var index = self Index
		return Paragraph ( Level (self Section, index), index )
	//[cf]

	//[of]:>	\:\: Line -> Boolean
	method _gt (otherline)
		return self Index > otherline Index
	//[cf]
	//[of]:<	\:\: Line -> Boolean
	method _lt (otherline)
		return self Index < otherline Index
	//[cf]
	//[of]:==	\:\: Line -> Boolean
	method _eq (otherline)
		return self Index == otherline Index
	//[cf]
	//[of]:<>	\:\: Line -> Boolean
	method _ne (otherline)
		return self Index <> otherline Index
	//[cf]

	//[of]:refresh	\:\: Line
	method refresh
		self _Row = nil
		self _Text = nil
		self _Indent = nil
		self _Indentstring = nil
		return self
	//[cf]
	//[of]:clone	\:\: Line
	//[c]Todo: add other data if it exists

	method clone
		return Line (self Section, self Index)
	//[cf]
	//[of]:paste	\:\: Location -> TextBlock -> Section
	//[c]The textblocks last line must be empty (aka, it ends with a newline)

	method paste (textblock)
		var y = self Index
		var sec = self Section
		sec Textsection replaceText (y, 0, y + 1, 0, textblock)
		if textblock size <> 1
			sec refreshdimensions
		end
		return self
	//[cf]
	//[of]:issamethan	\:\: Line -> Boolean
	method issamethan (otherline)
		return self Index == otherline Index
	//[cf]
	//[of]:isfirst	\:\: Boolean
	method isfirst
		return self Index == 0
	//[cf]
	//[of]:islast	\:\: Boolean
	method islast
		return self Index == self Section Endy
	//[cf]
	//[of]:isempty	\:\: Boolean
	method isempty
		return (self Text size == 0)

	//[cf]
	//[of]:issection	\:\: Boolean
	method issection
		return self Row type == lt_section
	//[cf]
	//[of]:islink	\:\: Boolean
	method islink
		return self Row type == lt_link
	//[cf]
	//[of]:isdescription	\:\: Boolean
	method isdescription
		return self Row type == lt_comment

	//[cf]
	//[of]:istext	\:\: Boolean
	method istext
		return self Row type == lt_text

	//[cf]
	//[of]:isopener	\:\: Boolean
	method isopener
		return self isdescription and self Text startsWith ("( ")
	//[cf]
	//[of]:iscloser	\:\: Boolean
	method iscloser
		return self isdescription and self Text toString == (")")
	//[cf]
	//[of]:prev	\:\: Line
	method prev
		if not self isfirst
			self Index = self Index - 1
			self refresh
		end
		return self
	//[cf]
	//[of]:next	\:\: Line
	method next
		if not self islast
			self Index = self Index + 1
			self refresh
		end
		return self
	//[cf]
	//[of]matchingcloser:matchingcloser	\:\: Line
	method matchingcloser (level)
	//[c]
	//[c]	~ assert(self isopener == true)

		var endline = level End
		var counter = 1
		while self < endline
			self next
			if self isopener
				counter = counter + 1
			elsif self iscloser
				counter = counter - 1
				if counter == 0
					return self
				end
			end
		end
		return Error
	//[cf]
	//[of]:matchingopener	\:\: Line
	method matchingopener (level)

	//[c]	~ assert(self iscloser == true)

		var startline = level Start
		var counter = 1
		while self > startline
			self prev
			if self isopener
				counter = counter - 1
				if counter == 0
					return self
				end
			elsif self iscloser
				counter = counter + 1
			end
		end
		return Error

	//[cf]
	//[of]fold:fold	\:\: Line
	method fold
		var para = self Paragraph
		var newline = para Start
		para fold
		newline refresh
		return newline
	//[cf]
	//[of]:unfold	\:\: Line
	method unfold
		var childssection = self Childsection
		var title_ = self Text toString
		if title_ <> "..."
			childssection prependcomment (Buf << "( " << title_)
			childssection appendcomment (Buf << ")")
		end
		var block = childssection copy
		indentblock (block, self Indent)
		self paste (block)
		self refresh
		return self
	//[cf]
	//[of]:outcomment	\:\: Line
	method outcomment
		var oc = self Section Opencomment
		var cc = self Section Closecomment
		var hasnolinecomment = cc notEmpty
		var buf = self Text
		if self istext and not self isempty
			buf = Buf << buf
			if hasnolinecomment
				buf = replace (buf, oc, "___oc___")
				buf = replace (buf, cc, "___cc___")
			end
			var block = TextBlock new
			block addComment ( (Buf << self Indentstring << "~ " << buf) toString )
			self paste (block)
		elsif self isdescription and buf startsWith ("~ ")
			var block = TextBlock new
			block addComment ( (Buf << self Indentstring << "~ " << buf) toString )
			self paste (block)
		elsif self issection
			self Childsection outcomment
			var block = self copy
			block setRowText (0, (Buf << self Indentstring << "~ " << buf) toString)
			self paste (block)
		end
		return self
	//[cf]
	//[of]:unoutcomment	\:\: Line
	method unoutcomment
		var oc = self Section Opencomment
		var cc = self Section Closecomment
		var hasnolinecomment = cc notEmpty
		var buf = self Text
		if self isdescription and buf startsWith ("~ ")
			buf = Buf << buf
			lcrop (buf, 2)
			var block = TextBlock new
			if not buf startsWith ("~ ")
				if hasnolinecomment
					buf = replace (buf, "___oc___", oc)
					buf = replace (buf, "___cc___", cc)
				end
				block addText ( (Buf << self Indentstring << buf) toString )
			else
				block addComment ( (Buf << self Indentstring << buf) toString )
			end
			self paste (block)
		elsif self issection
			self Childsection unoutcomment
			if buf startsWith ("~ ")
				var block = self copy
				buf = Buf << buf
				lcrop (buf, 2)
				block setRowText ( 0, (Buf << self Indentstring << buf) toString )
				self paste (block)
			end
		end
		return self
	//[cf]
	//[of]:copy	\:\: TextBlock
	method copy
		return self Section Textsection copyBlock (
		self Index, 0, self Index + 1, 0)
	//[cf]

	//[of]:D
	//[of]:~ isopener v1	\:\: Boolean
	//[c]~ method isopener
	//[c]	~ return self Text startsWith (self Section Opentoken)
	//[cf]
	//[of]:~ iscloser v1	\:\: Boolean
	//[c]~ method iscloser
	//[c]	~ return self Text startsWith (self Section Closetoken)
	//[cf]
	//[of]:~ unfold v1	\:\: Line
	//[c]~ method unfold
	//[c]	~ var childssection = self Childsection
	//[c]	~ var title_ = self Text toString
	//[c]	~ if title_ <> "..."
	//[c]		~ var sec = self Section
	//[c]		~ var oc = Buf << (sec Opentoken) << title_ <<
	//[c]			~ sec Closecomment << "\n"
	//[c]		~ childssection prepend (totextblock (oc))
	//[c]		~ var cc = Buf << (sec Closetoken) << "\n"
	//[c]		~ childssection append (totextblock (cc))
	//[c]	~ end
	//[c]	~ var block = childssection copy
	//[c]	~ indentblock (block, self Indent)
	//[c]	~ self paste (block)
	//[c]	~ self refresh
	//[c]	~ return self
	//[cf]
	//[cf]
//[cf]
//[c])
//[cf]
//[of]Actions:Actions
//[of]action_navigatenextsection	\:\: nil:action_navigatenextsection	\:\: nil
function action_navigatenextsection
	startundo
	var line_ = Activesection Cursorline
	if not line_ islast
		line_ next
		while not (line_ islast or line_ issection or
		line_ islink or line_ isopener)
			line_ next
		end
	end
	line_ Smartlocation putcursor
	stopundo
//[cf]
//[of]action_navigate_prev_section	-> nil:action_navigateprevsection	\:\: nil
function action_navigateprevsection
	startundo
	var line_ = Activesection Cursorline
	if not line_ isfirst
		line_ prev
		while not (line_ isfirst or line_ issection or line_ islink or
		line_ isopener)
			line_ prev
		end
	end
	line_ Smartlocation putcursor
	stopundo
//[cf]
//[of]action_navigatenextparagraph	\:\: nil:action_navigatenextparagraph	\:\: nil
function action_navigatenextparagraph
	startundo
	var line_ = Activesection Cursorline
	if not line_ islast
		if not line_ isempty
			line_ next
//[c]			~ while not (line_ islast or line_ isempty)
			while not line_ islast and not (line_ isempty or line_ isopener)
				line_ next
			end
		end
		while not line_ islast and (line_ isempty or line_ iscloser)
			line_ next
		end
	end
	line_ Smartlocation putcursor
	stopundo
//[cf]
//[of]:action_navigateprevparagraph	\:\: nil
function action_navigateprevparagraph
	startundo
	var line_ = Activesection Cursorline
	if not line_ isfirst
		line_ prev
		while not line_ isfirst and (line_ isempty or line_ iscloser)
			line_ prev
		end
		if not line_ isfirst
//[c]			~ while not (line_ isfirst or line_ isempty)
			while not line_ isfirst and not (line_ isempty or line_ isopener)
				line_ prev
			end
			while (line_ isempty or line_ iscloser)
				line_ next
			end
		end
	end
	line_ Smartlocation putcursor
	stopundo
//[cf]
//[of]action_fold	\:\: nil:action_fold	\:\: nil
function action_fold
	startundo
	var sec = Activesection
	var line_ = sec Cursorline
	if line_ isempty
//[c]		Todo: what to do when folding an empty line?
//[c]		fold all blocks in level?
	else
		var newline = line_ fold
		var linestart = newline Startlocation
		Range (linestart, newline Endlocation) select
	end
	stopundo
//[cf]
//[of]action_unfold	\:\: nil:action_unfold	\:\: nil
function action_unfold
	startundo
	var line_ = Activesection Cursorline
	if line_ issection
		line_ unfold
		line_ Smartlocation putcursor
	end
	stopundo
//[cf]
//[of]:action_moveup	\:\: nil
function action_moveup
	startundo
	var sec = Activesection
	var sel = sec Selection
	var then = sel clone up
	sel normdirection
	if sel Start Y > 0
		sel blockify
		if sel End Y > sec Endy
			sec appendnewline
		end
		var textblock = sel cut
		sel Start up paste (textblock)
		then select
	end
	stopundo
//[cf]
//[of]:action_movedown	\:\: nil
function action_movedown
	startundo
	var sec = Activesection
	var sel = sec Selection
	var then = sel clone down
	sel normdirection blockify
	if sel End Y == sec Endy
		sec appendnewline
	end
	var textblock = sel cut
	if sec Endy == sel Start Y
		sec appendnewline
	end
	sel Start down paste (textblock)
	then select
	stopundo
//[cf]
//[of]:action_outcomment	\:\: nil
function action_outcomment
	startundo
	var sec = Activesection
	var sel = sec Selection
	var remember = sel clone
	sel blockify normdirection
	if sel End Y > sec Endy
		sec appendnewline
	end
	sel outcomment
	remember select
	stopundo
//[cf]
//[of]:action_unoutcomment	\:\: nil
function action_unoutcomment
	startundo
	var sec = Activesection
	var sel = sec Selection
	var remember = sel clone
	sel blockify normdirection
	if sel End Y > sec Endy
		sec appendnewline
	end
	sel unoutcomment
	remember select
	stopundo
//[cf]
//[of]:action_gotodefinition	\:\: nil
//[c]This is not fully implemented yet

function action_gotodefinition
	startundo
	var identifier = Selectedtext
	if identifier <> ""
		var findresult = Activesection Find definition (
			Activelanguage name,
			identifier)
		if findresult notNil
			findresult Location putcursor
		end
	end
	stopundo
//[cf]
//[cf]
//[of]Error Handling:Error Handling
//[c]Todo: Extend

//[of]:Error
function Error
	stopundo
	print ("Error")
	return ScriptError basicNew

class ScriptError
//[c]	this class does nothing, so that Code Browser will raise when the
//[c]	script tries to call methods on it. This is currently not very helpful
//[c]	because messages printed to the console are not shown on hard errors, like
//[c]	calling a non-existent method.
//[cf]
//[of]:assert	\:\: Boolean -> nil
function assert (what)
//[c]	used in test functions
	var o = Output clear
	if not what
		o print ("Assertion Error")
	else
		o print ("OK")
	end
//[cf]
//[cf]

//[of]Notes:Notes
//[of]:Solving language related problems
//[c]The Code Browser script language is, with a few exceptions, easy to use and
//[c]nice to read. But as script language it misses some features from more
//[c]powerful languages:
//[c]
//[c]* Session persistent variables
//[c]* Arrays, dicts, tuples, sets
//[c]* Class extension, especially of built in classes.
//[c]* Powerful regular expressions. (Like eg. in Pythons regex module).
//[c]* Variadic function arguments or function overloading or the possibility
//[c]  to check the type of a parameter (only isNil available).
//[c]* Exception handling.
//[c]* The possibility to abort the script.
//[c]
//[c]I solve some of these problems as follows:
//[c]
//[c]Global variables become an attribute of usually the Section class as it gets
//[c]instantiated in every script anyway. Other classes have a reference to it.
//[c]
//[c]Instead of class extension i use Wrapper classes. Eg. the Section class wraps
//[c]a Code Browser TextSection class.
//[c]
//[c]No variadic func args, no function overloading: Variadic args become class
//[c]attributes and i pass that class instance instead.
//[c]
//[c]No possibilities of checking the type of a thing: If this is needed, i add a
//[c]'Type' attribute to the class, which describes the class, and i check against
//[c]this. But currently not used.
//[c]
//[c]No exception / abort mechanism: No elegant solution for that.
//[c]
//[c]In short, it would be simpler if the script language was Python.
//[c]
//[cf]
//[of]Variable, class and function naming:Variable, class and function naming
//[c]Local variables as well as functions are written in small letters and never
//[c]use underscores. For example
//[c]
//[c]	mylocalvar
//[c]
//[c]and not
//[c]
//[c]	my_local_var
//[c]	myLocalVar
//[c]
//[c]Classes and global or class level Getter properties (= functions which
//[c]take no arguments and return something except self) always start with a big
//[c]letter, followed by zero or more small letters. Also no underscores.
//[c]For example
//[c]
//[c]	Myclass
//[c]	Myglobalproperty
//[c]	mylocalvar Myproperty
//[c]
//[c]and not
//[c]
//[c]	My_Class
//[c]	MyGlobalProperty
//[c]	mylocalvar my_property
//[c]
//[c]This is to distinguish them from local variables (reflected by the code
//[c]coloring). I have edited the Code-Browser-Script language in preferences.cbc
//[c]so that the color of local variables is blue and the color of other variables,
//[c]as well as functions and classes is purple.
//[c]
//[c]The syntax is also overall more pleasant to read in my opinion.
//[c]
//[c]'private' class attributes and helper functions and methods start with an
//[c]underscore. As usual, this means they are not intended to be used outside
//[c]of the library.
//[c]
//[l]:Script functions:#Actions
//[c]which are assigned to shortcuts in the
//[l]:user.cbc:user.cbc
//[c]start with 'action_'.
//[c]
//[c]
//[c]If identifiers dont follow this naming scheme then they are predefined by
//[c]Code Browser.
//[c]
//[cf]
//[of]Ordering of function arguments:Ordering of function arguments
//[c]The ordering of function arguments reflects how they would be ordered when they
//[c]would form a normal sentence (the verb moved to the start). For example the
//[c]sentence
//[c]
//[c]	3 times "foo"
//[c]
//[c]becomes the function call
//[c]
//[c]	times (3, "foo")
//[c]
//[c]and not
//[c]
//[c]	times ("foo", 3)
//[c]
//[cf]
//[of]Where are the methods located?:Where are class methods located?
//[c]The methods are attached to the object which requires the least arguments. Eg.
//[c]
//[c]	Line cut
//[c]
//[c]and not
//[c]
//[c]	Section cutline (index)
//[c]
//[c](This works because Section and index are attributes of the Line class)
//[c]
//[c]or
//[c]
//[c]	Location putcursor
//[c]
//[c]and not
//[c]
//[c]	Section putcursor (location)
//[c]
//[c](Here Section is an attribute of the Location class)
//[cf]
//[cf]

//[l]:user.cbc:user.cbc
